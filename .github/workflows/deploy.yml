name: ğŸš€ Deploy DigiUrban Unified System

concurrency:
  group: digiurban-unified-production-deploy
  cancel-in-progress: true

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  VPS_HOST: '72.60.10.108'
  VPS_USER: 'root'
  APP_DIR: '/root/digiurban-unified'
  APP_PORT: '3020'
  CONTAINER_NAME: 'digiurban-unified'

jobs:
  deploy:
    name: ğŸ¯ Deploy Unified Container
    runs-on: ubuntu-latest
    timeout-minutes: 60
    
    steps:
    - name: ğŸ“‹ InformaÃ§Ãµes do Deploy
      run: |
        echo "=============================================="
        echo "ğŸš€ INICIANDO DEPLOY DIGIURBAN UNIFIED SYSTEM"
        echo "=============================================="
        echo "ğŸ“¦ Commit: ${{ github.sha }}"
        echo "ğŸŒ¿ Branch: ${{ github.ref_name }}"
        echo "ğŸ‘¤ Actor: ${{ github.actor }}"
        echo "â° Timestamp: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
        echo "ğŸ¯ Target: ${{ env.VPS_HOST }}:${{ env.APP_PORT }}"
        echo "=============================================="
        
        # VariÃ¡vel para tracking do tempo
        echo "DEPLOY_START_TIME=$(date +%s)" >> $GITHUB_ENV

    - name: ğŸ”§ Configurar SSH e Ferramentas
      run: |
        echo "ğŸ”§ Configurando SSH e ferramentas necessÃ¡rias..."
        sudo apt-get update -qq
        sudo apt-get install -y sshpass rsync curl jq
        
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        ssh-keyscan -H ${{ env.VPS_HOST }} >> ~/.ssh/known_hosts 2>/dev/null
        
        echo "ğŸ” Testando conexÃ£o SSH..."
        if sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o ConnectTimeout=30 -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "echo 'âœ… SSH funcionando'"; then
          echo "âœ… SSH configurado com sucesso"
        else
          echo "âŒ Falha na conexÃ£o SSH"
          exit 1
        fi

    - name: ğŸ“¥ Checkout do CÃ³digo
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: ğŸŸ¢ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'

    - name: ğŸ“Š AnÃ¡lise Pre-Deploy
      run: |
        echo "ğŸ“Š Analisando estrutura do projeto..."
        echo "=================================="
        
        echo "ğŸ“ Estrutura raiz:"
        ls -la
        
        echo ""
        echo "ğŸ“ Backend:"
        if [ -d "backend" ]; then
          ls -la backend/
          if [ -f "backend/package.json" ]; then
            echo "âœ… package.json encontrado"
            echo "ğŸ“¦ DependÃªncias principais:"
            cat backend/package.json | jq -r '.dependencies | keys | .[]' | head -5
          fi
        else
          echo "âŒ DiretÃ³rio backend nÃ£o encontrado"
        fi
        
        echo ""
        echo "ğŸ“ Frontend:"
        if [ -d "frontend" ]; then
          ls -la frontend/
          if [ -f "frontend/package.json" ]; then
            echo "âœ… package.json encontrado"
            echo "ğŸ“¦ DependÃªncias principais:"
            cat frontend/package.json | jq -r '.dependencies | keys | .[]' | head -5
          fi
        else
          echo "âŒ DiretÃ³rio frontend nÃ£o encontrado"
        fi
        
        echo ""
        echo "ğŸ³ Docker:"
        ls -la Dockerfile* docker-compose* 2>/dev/null || echo "âš ï¸ Arquivos Docker nÃ£o encontrados"

    - name: ğŸ—ï¸ Build Local do Backend
      run: |
        echo "ğŸ—ï¸ Iniciando build local do backend..."
        echo "======================================"

        if [ ! -d "backend" ]; then
          echo "âŒ DiretÃ³rio backend nÃ£o encontrado"
          exit 1
        fi

        echo "ğŸ” Verificando schema.prisma..."
        if [ ! -f "schema.prisma" ]; then
          echo "âŒ Schema Prisma nÃ£o encontrado na raiz"
          exit 1
        fi

        cd backend

        echo "ğŸ“¦ Instalando dependÃªncias do backend..."
        if npm install --no-optional; then
          echo "âœ… DependÃªncias instaladas com sucesso"
        else
          echo "âŒ Falha ao instalar dependÃªncias"
          exit 1
        fi

        echo "ğŸ”§ Configurando ambiente Prisma para CI..."
        # Limpar cache e configurar para download automÃ¡tico
        export PRISMA_SKIP_POSTINSTALL_GENERATE=true
        export PRISMA_BINARIES_MIRROR=https://binaries.prisma.sh

        echo "ğŸ§¹ Limpando cache do Prisma..."
        rm -rf ~/.cache/prisma
        rm -rf node_modules/.prisma
        rm -rf node_modules/@prisma

        echo "ğŸ”§ Verificando Prisma CLI..."
        npx prisma --version

        echo "ğŸ”§ Gerando Prisma Client..."
        if npm run db:generate; then
          echo "âœ… Prisma Client gerado com sucesso"
        else
          echo "âŒ Tentando com configuraÃ§Ãµes alternativas..."
          # Primeira tentativa: reinstalar dependÃªncias Prisma
          echo "ğŸ“¦ Reinstalando dependÃªncias Prisma..."
          npm install @prisma/client prisma --force

          if npm run db:generate; then
            echo "âœ… Prisma Client gerado apÃ³s reinstalaÃ§Ã£o"
          else
            echo "âŒ Tentando diretamente com npx..."
            # Segunda tentativa: forÃ§ar download
            if npx prisma generate --schema=../schema.prisma; then
              echo "âœ… Prisma Client gerado com npx direto"
            else
              echo "âŒ Falha ao gerar Prisma Client"
              exit 1
            fi
          fi
        fi

        echo "ğŸ”¨ Compilando TypeScript..."
        if npm run build; then
          echo "âœ… Build do backend concluÃ­do com sucesso"
          echo "ğŸ“Š Analisando build:"
          ls -la dist/
          echo "ğŸ“ˆ Tamanho do build: $(du -sh dist/)"
          echo "ğŸ“ Arquivos gerados: $(find dist/ -type f | wc -l)"
        else
          echo "âŒ Falha no build do backend"
          exit 1
        fi

    - name: âš›ï¸ Build Local do Frontend  
      run: |
        echo "âš›ï¸ Iniciando build local do frontend..."
        echo "======================================"
        
        if [ ! -d "frontend" ]; then
          echo "âŒ DiretÃ³rio frontend nÃ£o encontrado"
          exit 1
        fi
        
        cd frontend
        
        echo "ğŸ“¦ Instalando dependÃªncias do frontend..."
        if npm install; then
          echo "âœ… DependÃªncias instaladas com sucesso"
        else
          echo "âŒ Falha ao instalar dependÃªncias"
          exit 1
        fi
        
        echo "ğŸ”¨ Compilando React/Vite..."
        if npm run build; then
          echo "âœ… Build do frontend concluÃ­do com sucesso"
          echo "ğŸ“Š Analisando build:"
          ls -la dist/
          echo "ğŸ“ˆ Tamanho do build: $(du -sh dist/)"
          echo "ğŸ“ Arquivos gerados: $(find dist/ -type f | wc -l)"
          
          # Verificar se arquivos essenciais foram gerados
          if [ -f "dist/index.html" ]; then
            echo "âœ… index.html encontrado"
          else
            echo "âŒ index.html nÃ£o encontrado"
            exit 1
          fi
        else
          echo "âŒ Falha no build do frontend"
          exit 1
        fi

    - name: ğŸ§¹ Preparar VPS
      run: |
        echo "ğŸ§¹ Preparando ambiente na VPS..."
        echo "================================"
        
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
        echo 'ğŸ”„ Atualizando sistema...'
        apt-get update -y > /dev/null 2>&1
        
        echo 'ğŸŸ¢ Instalando Node.js 20.x...'
        curl -fsSL https://deb.nodesource.com/setup_20.x | bash - > /dev/null 2>&1
        apt-get install -y nodejs > /dev/null 2>&1
        
        echo 'ğŸ³ Configurando Docker...'
        apt-get remove -y docker docker-engine docker.io containerd runc containerd.io 2>/dev/null || true
        apt-get install -y apt-transport-https ca-certificates curl gnupg lsb-release > /dev/null 2>&1
        curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 2>/dev/null
        echo \"deb [arch=\$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \$(lsb_release -cs) stable\" | tee /etc/apt/sources.list.d/docker.list > /dev/null
        apt-get update -y > /dev/null 2>&1
        apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin > /dev/null 2>&1
        
        systemctl start docker
        systemctl enable docker
        
        echo 'âœ… VersÃµes instaladas:'
        node --version
        npm --version
        docker --version
        "

    - name: ğŸ§¹ Limpeza de Containers Antigos
      timeout-minutes: 5
      run: |
        echo "ğŸ§¹ Removendo containers e imagens antigas..."
        echo "============================================"
        
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
        echo 'ğŸ›‘ Parando TODOS os containers DigiUrban...'
        
        # Parar containers da arquitetura antiga (se existirem)
        docker stop digiurban-frontend digiurban-backend 2>/dev/null && echo 'âœ… Containers antigos parados' || echo 'â„¹ï¸  Nenhum container antigo'
        docker rm digiurban-frontend digiurban-backend 2>/dev/null && echo 'âœ… Containers antigos removidos' || echo 'â„¹ï¸  Nenhum container antigo para remover'
        
        # Parar container unificado atual
        docker stop ${{ env.CONTAINER_NAME }} 2>/dev/null && echo 'âœ… Container unificado parado' || echo 'â„¹ï¸  Nenhum container unificado rodando'
        docker rm ${{ env.CONTAINER_NAME }} 2>/dev/null && echo 'âœ… Container unificado removido' || echo 'â„¹ï¸  Nenhum container unificado para remover'
        
        echo 'ğŸ—‘ï¸  Removendo TODAS as imagens DigiUrban...'
        docker rmi digiurban-frontend:latest digiurban-backend:latest digiurban-unified:latest 2>/dev/null && echo 'âœ… Imagens antigas removidas' || echo 'â„¹ï¸  Nenhuma imagem antiga para remover'
        
        echo 'ğŸ§½ Limpeza especÃ­fica de Docker...'
        docker image prune -f --filter until=24h || echo 'âš ï¸ NÃ£o foi possÃ­vel limpar imagens antigas'
        docker container prune -f || echo 'âš ï¸ NÃ£o foi possÃ­vel limpar containers parados'
        echo 'âœ… Limpeza especÃ­fica concluÃ­da'
        
        echo 'ğŸ“ Preparando diretÃ³rio...'
        rm -rf ${{ env.APP_DIR }}
        mkdir -p ${{ env.APP_DIR }}
        echo 'âœ… DiretÃ³rio preparado'
        "

    - name: ğŸ“¤ Transferir CÃ³digo para VPS
      run: |
        echo "ğŸ“¤ Transferindo cÃ³digo para VPS..."
        echo "=================================="
        
        echo "ğŸ“Š Analisando arquivos a transferir..."
        echo "Tamanho total: $(du -sh . | cut -f1)"
        
        echo "ğŸš€ Iniciando transferÃªncia..."
        if sshpass -p "${{ secrets.VPS_PASSWORD }}" rsync -avz --progress --delete \
          --exclude='.git/' \
          --exclude='node_modules/' \
          --exclude='frontend/node_modules/' \
          --exclude='backend/node_modules/' \
          --exclude='.claude/' \
          -e "ssh -o StrictHostKeyChecking=no" \
          ./ ${{ env.VPS_USER }}@${{ env.VPS_HOST }}:${{ env.APP_DIR }}/; then
          echo "âœ… CÃ³digo transferido com sucesso"
        else
          echo "âŒ Falha na transferÃªncia"
          exit 1
        fi

    - name: ğŸ³ Build e Deploy Container
      run: |
        echo "ğŸ³ Construindo e deployando container..."
        echo "======================================="
        
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
        cd ${{ env.APP_DIR }}
        
        echo 'ğŸ“‹ Verificando estrutura transferida...'
        ls -la
        
        echo 'ğŸ” Verificando arquivos Docker...'
        ls -la Dockerfile docker-compose.yml nginx-unified.conf start-services.sh 2>/dev/null || echo 'âš ï¸ Alguns arquivos Docker podem estar ausentes'
        
        echo 'âœ… Tornando scripts executÃ¡veis...'
        chmod +x start-services.sh 2>/dev/null || echo 'â„¹ï¸  Script nÃ£o encontrado'
        
        echo 'ğŸ—ï¸ Construindo container (isso pode levar alguns minutos)...'
        if docker compose build --no-cache; then
          echo 'âœ… Container construÃ­do com sucesso'
        else
          echo 'âŒ Falha na construÃ§Ã£o do container'
          exit 1
        fi
        
        echo 'ğŸš€ Iniciando container...'
        if docker compose up -d; then
          echo 'âœ… Container iniciado'
        else
          echo 'âŒ Falha ao iniciar container'
          exit 1
        fi
        
        echo 'ğŸ“Š Status dos containers:'
        docker compose ps
        "

    - name: ğŸ—ƒï¸ Executar Database Migrations
      run: |
        echo "ğŸ—ƒï¸ Executando migrations do banco de dados..."
        echo "============================================="
        
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
        cd ${{ env.APP_DIR }}
        
        echo 'ğŸ” Verificando estrutura Prisma...'
        if [ -f 'schema.prisma' ]; then
          echo 'âœ… Schema Prisma encontrado'
          echo 'ğŸ“Š Verificando schema...'
          head -20 schema.prisma
        else
          echo 'âŒ Schema Prisma nÃ£o encontrado'
          exit 1
        fi
        
        echo ''
        echo 'ğŸ§¹ Limpando banco anterior se necessÃ¡rio...'
        docker exec ${{ env.CONTAINER_NAME }} sh -c '
          if [ -f /app/data/digiurban.db ]; then
            echo "Removendo banco anterior..."
            rm -f /app/data/digiurban.db*
            echo "âœ… Banco anterior removido"
          else
            echo "â„¹ï¸ Nenhum banco anterior encontrado"
          fi
        '
        
        echo ''
        echo 'ğŸ—ƒï¸ Configurando banco de dados...'

        # Aguardar container estar totalmente iniciado (mesmo tempo do deploy local)
        echo 'â³ Aguardando container inicializar...'
        sleep 20

        echo 'ğŸ” Verificando se container estÃ¡ respondendo...'
        i=1
        while [ \$i -le 10 ]; do
          if docker exec ${{ env.CONTAINER_NAME }} sh -c 'echo "Container ready"' >/dev/null 2>&1; then
            echo 'âœ… Container estÃ¡ respondendo'
            break
          fi
          echo "   Tentativa \$i/10..."
          sleep 3
          i=\$((i + 1))
        done

        echo 'ğŸ§¹ Limpando banco anterior se necessÃ¡rio...'
        docker exec ${{ env.CONTAINER_NAME }} sh -c 'rm -f /app/data/digiurban.db* 2>/dev/null || echo "Nenhum banco para limpar"'

        # Usar mesmo comando do deploy local que funciona
        echo 'ğŸš€ Criando schema do banco de dados...'
        if docker exec -e DATABASE_URL="file:/app/data/digiurban.db" ${{ env.CONTAINER_NAME }} sh -c 'cd /app/backend && npx prisma db push --schema=../schema.prisma'; then
          echo 'âœ… Schema do banco criado com sucesso'
        else
          echo 'âŒ Falha ao criar schema'
          docker logs ${{ env.CONTAINER_NAME }} --tail 50
          exit 1
        fi

        echo 'ğŸ¯ Executando seeds do banco...'
        if docker exec -e DATABASE_URL="file:/app/data/digiurban.db" -e INITIAL_ADMIN_EMAIL=admin@digiurban.com.br -e INITIAL_ADMIN_PASSWORD=admin123 -e INITIAL_ADMIN_NAME="Super Administrador" ${{ env.CONTAINER_NAME }} sh -c 'cd /app/backend && node dist/database/seed.js'; then
          echo 'âœ… Seeds executados com sucesso'
        else
          echo 'âš ï¸ Erro nos seeds, mas continuando deploy'
        fi

        echo 'ğŸ”“ Ativando usuÃ¡rios criados...'
        printf '%s\n' \
          "const { PrismaClient } = require('@prisma/client');" \
          "(async () => {" \
          "  const prisma = new PrismaClient();" \
          "  const result = await prisma.user.updateMany({" \
          "    data: { status: 'ativo' }" \
          "  });" \
          "  console.log('âœ… ' + result.count + ' usuÃ¡rios ativados');" \
          "  await prisma.\$disconnect();" \
          "})().catch(console.error);" > activate_users.js

        if docker cp activate_users.js ${{ env.CONTAINER_NAME }}:/app/backend/activate_users.js; then
          docker exec -e DATABASE_URL="file:/app/data/digiurban.db" ${{ env.CONTAINER_NAME }} sh -c 'cd /app/backend && node activate_users.js' || echo 'âš ï¸ AtivaÃ§Ã£o com warnings'
          docker exec ${{ env.CONTAINER_NAME }} sh -c 'rm -f /app/backend/activate_users.js'
        else
          echo 'âš ï¸ Falha ao copiar script de ativaÃ§Ã£o'
        fi
        rm -f activate_users.js

        # Verificar integridade do banco usando CommonJS
        echo ''
        echo 'ğŸ” Verificando integridade do banco...'
        printf '%s\n' \
          "const { PrismaClient } = require('@prisma/client');" \
          "(async () => {" \
          "  const prisma = new PrismaClient();" \
          "  try {" \
          "    const result = await prisma.\$queryRaw\`SELECT name FROM sqlite_master WHERE type=\"table\" ORDER BY name\`;" \
          "    console.log('ğŸ“‹ Tabelas criadas:', result.length);" \
          "    result.forEach(t => console.log('  â€¢', t.name));" \
          "    const admin = await prisma.user.findFirst({" \
          "      where: { role: 'super_admin' }," \
          "      select: { email: true, role: true, status: true }" \
          "    });" \
          "    console.log('ğŸ‘¤ Super admin:', admin ? admin.email + ' [' + admin.status + ']' : 'NÃƒO ENCONTRADO');" \
          "    try {" \
          "      const smtpUsers = await prisma.smtpUser.count();" \
          "      const emailDomains = await prisma.emailDomain.count();" \
          "      console.log('ğŸ“§ UsuÃ¡rios SMTP:', smtpUsers);" \
          "      console.log('ğŸŒ DomÃ­nios Email:', emailDomains);" \
          "    } catch (e) {" \
          "      console.log('â„¹ï¸  Tabelas de email nÃ£o criadas ainda');" \
          "    }" \
          "    await prisma.\$disconnect();" \
          "  } catch (error) {" \
          "    console.error('âŒ Erro na verificaÃ§Ã£o:', error.message);" \
          "    await prisma.\$disconnect();" \
          "    process.exit(1);" \
          "  }" \
          "})();" > verify_db.js

        if docker cp verify_db.js ${{ env.CONTAINER_NAME }}:/app/backend/verify_db.js; then
          docker exec -e DATABASE_URL="file:/app/data/digiurban.db" ${{ env.CONTAINER_NAME }} sh -c 'cd /app/backend && node verify_db.js' || echo 'âš ï¸ VerificaÃ§Ã£o com warnings'
          docker exec ${{ env.CONTAINER_NAME }} sh -c 'rm -f /app/backend/verify_db.js'
        else
          echo 'âš ï¸ Falha ao copiar script de verificaÃ§Ã£o'
        fi
        rm -f verify_db.js

        echo ''
        echo 'ğŸ§ª Testando login do super admin...'
        sleep 5
        LOGIN_DATA='{"email":"admin@digiurban.com.br","password":"admin123"}'
        if curl -f -X POST http://localhost:3020/api/auth/login -H 'Content-Type: application/json' -d "$LOGIN_DATA" --max-time 10 | grep -q '"success":true'; then
          echo 'âœ… Login do super admin funcionando!'
        else
          echo 'âš ï¸ Login do super admin nÃ£o testado com sucesso'
        fi
        "

    - name: ğŸ¥ Health Checks Inteligentes
      run: |
        echo "ğŸ¥ Executando health checks inteligentes..."
        echo "=========================================="
        
        echo ""
        echo "ğŸ¥ Aguardando inicializaÃ§Ã£o completa (60s)..."
        sleep 60

        # Health check do backend
        echo "ğŸ” Verificando Backend API..."
        BACKEND_FAILED=0
        max_attempts=20
        delay=15

        attempt=1
        while [ $attempt -le $max_attempts ]; do
          total_wait=$((attempt * delay))
          echo "â³ Tentativa $attempt/$max_attempts (${total_wait}s total) - Backend API"

          response=$(curl -s -o /dev/null -w "%{http_code}|%{time_total}" "http://${{ env.VPS_HOST }}:${{ env.APP_PORT }}/api/health" 2>/dev/null || echo "000|0")
          http_code=$(echo $response | cut -d'|' -f1)
          time_total=$(echo $response | cut -d'|' -f2)

          if [ "$http_code" = "200" ]; then
            echo "âœ… Backend API: Respondendo corretamente (${time_total}s)"
            break
          elif [ "$http_code" = "000" ]; then
            echo "â³ Backend API: ServiÃ§o ainda nÃ£o responde..."
          else
            echo "âš ï¸  Backend API: HTTP $http_code (aguardando...)"
          fi

          if [ $attempt -eq $max_attempts ]; then
            echo "âŒ Backend API: Falhou apÃ³s $max_attempts tentativas"
            BACKEND_FAILED=1
          else
            sleep $delay
          fi
          attempt=$((attempt + 1))
        done

        echo ""

        # Health check do frontend
        echo "ğŸ” Verificando Frontend..."
        FRONTEND_FAILED=0

        attempt=1
        while [ $attempt -le $max_attempts ]; do
          total_wait=$((attempt * delay))
          echo "â³ Tentativa $attempt/$max_attempts (${total_wait}s total) - Frontend"

          response=$(curl -s -o /dev/null -w "%{http_code}|%{time_total}" "http://${{ env.VPS_HOST }}:${{ env.APP_PORT }}/" 2>/dev/null || echo "000|0")
          http_code=$(echo $response | cut -d'|' -f1)
          time_total=$(echo $response | cut -d'|' -f2)

          if [ "$http_code" = "200" ]; then
            echo "âœ… Frontend: Respondendo corretamente (${time_total}s)"
            break
          elif [ "$http_code" = "000" ]; then
            echo "â³ Frontend: ServiÃ§o ainda nÃ£o responde..."
          else
            echo "âš ï¸  Frontend: HTTP $http_code (aguardando...)"
          fi

          if [ $attempt -eq $max_attempts ]; then
            echo "âŒ Frontend: Falhou apÃ³s $max_attempts tentativas"
            FRONTEND_FAILED=1
          else
            sleep $delay
          fi
          attempt=$((attempt + 1))
        done
        
        # Verificar logs se houver falha
        if [ "${BACKEND_FAILED}" = "1" ] || [ "${FRONTEND_FAILED}" = "1" ]; then
          echo ""
          echo "ğŸ” Coletando logs para diagnÃ³stico..."
          echo "===================================="
          
          sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
          cd ${{ env.APP_DIR }}
          echo 'ğŸ“‹ Status dos containers:'
          docker compose ps
          echo ''
          echo 'ğŸ“ Logs recentes (Ãºltimas 50 linhas):'
          docker compose logs --tail=50
          "
          
          exit 1
        fi

    - name: ğŸ§ª Testes de IntegraÃ§Ã£o
      run: |
        echo "ğŸ§ª Executando testes de integraÃ§Ã£o..."
        echo "==================================="

        # Aguardar sistema estabilizar
        sleep 30

        # Executar health check
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
        cd ${{ env.APP_DIR }}
        docker exec ${{ env.CONTAINER_NAME }} /app/scripts/health-check.sh
        "

        # Executar testes de integraÃ§Ã£o
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
        cd ${{ env.APP_DIR }}
        docker exec ${{ env.CONTAINER_NAME }} /app/scripts/integration-tests.sh
        "

        # Status do banco
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
        cd ${{ env.APP_DIR }}
        docker exec ${{ env.CONTAINER_NAME }} /app/scripts/database-status.sh
        "

    - name: ğŸ“Š RelatÃ³rio Final
      if: always()
      run: |
        echo "ğŸ“Š RELATÃ“RIO FINAL DO DEPLOY"
        echo "=========================="
        echo "ğŸ¯ Ambiente: ProduÃ§Ã£o"
        echo "ğŸŒ URL: http://${{ env.VPS_HOST }}:${{ env.APP_PORT }}"
        echo "ğŸ“… Deploy: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
        echo "ğŸ“¦ Commit: ${{ github.sha }}"
        echo "âœ… Status: DEPLOY CONCLUÃDO"

    - name: âœ… VerificaÃ§Ã£o Final e Resumo
      if: success()
      run: |
        DEPLOY_END_TIME=$(date +%s)
        DEPLOY_DURATION=$((DEPLOY_END_TIME - DEPLOY_START_TIME))
        DURATION_FORMATTED=$(printf '%02d:%02d:%02d' $((DEPLOY_DURATION/3600)) $((DEPLOY_DURATION%3600/60)) $((DEPLOY_DURATION%60)))
        
        echo "ğŸ‰ DEPLOY CONCLUÃDO COM SUCESSO!"
        echo "================================"
        echo "â±ï¸  Tempo total: $DURATION_FORMATTED"
        echo "ğŸŒ AplicaÃ§Ã£o: http://${{ env.VPS_HOST }}:${{ env.APP_PORT }}"
        echo "ğŸ¥ Health Check: http://${{ env.VPS_HOST }}:${{ env.APP_PORT }}/api/health"
        echo "ğŸ“Š Status: ONLINE âœ…"
        echo ""
        
        # VerificaÃ§Ã£o final dos serviÃ§os
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
        cd ${{ env.APP_DIR }}
        echo 'ğŸ“Š Status final dos containers:'
        docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}'
        echo ''
        echo 'ğŸ’¾ Uso de recursos:'
        docker stats --no-stream --format 'table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}'
        "
        
        echo ""
        echo "ğŸŠğŸŠğŸŠ DEPLOY FINALIZADO COM SUCESSO! ğŸŠğŸŠğŸŠ"

    - name: âŒ Deploy Failed - DiagnÃ³stico
      if: failure()
      run: |
        DEPLOY_END_TIME=$(date +%s)
        DEPLOY_DURATION=$((DEPLOY_END_TIME - DEPLOY_START_TIME))
        DURATION_FORMATTED=$(printf '%02d:%02d:%02d' $((DEPLOY_DURATION/3600)) $((DEPLOY_DURATION%3600/60)) $((DEPLOY_DURATION%60)))
        
        echo "âŒ DEPLOY FALHOU!"
        echo "=================="
        echo "â±ï¸  Tempo atÃ© falha: $DURATION_FORMATTED"
        echo "ğŸ“Š Status: FAILED âŒ"
        echo ""
        echo "ğŸ” Coletando informaÃ§Ãµes de diagnÃ³stico..."
        
        # Coletar logs detalhados
        sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "
        echo 'ğŸ“‹ Containers em execuÃ§Ã£o:'
        docker ps -a
        echo ''
        echo 'ğŸ“ Logs completos do sistema:'
        cd ${{ env.APP_DIR }} 2>/dev/null && docker compose logs --tail=100 || echo 'NÃ£o foi possÃ­vel acessar logs do docker compose'
        echo ''
        echo 'ğŸ’¾ Uso de disco:'
        df -h
        echo ''
        echo 'ğŸ§  Uso de memÃ³ria:'
        free -h
        " 2>/dev/null || echo "NÃ£o foi possÃ­vel conectar Ã  VPS para diagnÃ³stico"
        
        echo ""
        echo "ğŸ’¥ğŸ’¥ğŸ’¥ DEPLOY FALHOU - VERIFIQUE OS LOGS ACIMA ğŸ’¥ğŸ’¥ğŸ’¥"
        
        exit 1